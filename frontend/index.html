<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NavGuard - SafeWalk Vancouver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            font-family: 'Inter', sans-serif;
        }
        #map {
            z-index: 1;
        }
    </style>
</head>
<body class="h-screen overflow-hidden">
    <div class="flex h-full">
        <!-- Left Sidebar (Controls) -->
        <div class="flex-none w-1/3 bg-blue-900 text-white p-6 overflow-y-auto">
            <h1 class="text-3xl font-bold mb-6">SafeWalk Vancouver</h1>
            
            <!-- Route Inputs -->
            <div class="space-y-4 mb-6">
                <div>
                    <label for="start-node" class="block text-sm font-medium mb-2">Start Location:</label>
                    <select id="start-node" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-black px-3 py-2"></select>
                </div>
                <div>
                    <label for="end-node" class="block text-sm font-medium mb-2 mt-4">End Location:</label>
                    <select id="end-node" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm text-black px-3 py-2"></select>
                </div>
            </div>

            <!-- Time Slider -->
            <div class="mb-6">
                <label class="block text-sm font-semibold mb-2">
                    Time of Day: <span id="time-label" class="text-blue-300">12:00 PM</span>
                </label>
                <input 
                    type="range" 
                    id="time-slider" 
                    min="0" 
                    max="23" 
                    value="12" 
                    class="w-full"
                >
            </div>

            <!-- Route Details Panel -->
            <div class="mt-6">
                <h2 class="text-xl font-semibold mb-4">Route Details</h2>
                <div id="details-panel" class="bg-blue-800 rounded-lg p-4 min-h-[200px]">
                    <p class="text-gray-300">Click a route on the map to see details.</p>
                </div>
            </div>
        </div>

        <!-- Main Content Area (Map) -->
        <div class="flex-grow bg-gray-200 relative overflow-hidden">
            <div id="map" class="h-full w-full"></div>
        </div>
    </div>

    <script>
        // Scoring Weights
        const W_INFRASTRUCTURE = 2.5;
        const W_LIGHTING = 2.0;
        const W_AMENITY = 1.5;
        const W_CRIME = -3.0;
        const W_DISRUPTION = -2.0;

        // Mock City Data - Nodes (locations in Vancouver)
        const nodes = {
            'A': [49.2827, -123.1207], // Gastown
            'B': [49.2810, -123.1190], // Waterfront Station
            'C': [49.2780, -123.1230], // Granville Street
            'D': [49.2790, -123.1250], // Vancouver Art Gallery
            'E': [49.2760, -123.1280], // Yaletown
            'F': [49.2740, -123.1200]  // Library Square
        };

        // Node names for display
        const nodeNames = {
            'A': 'Gastown',
            'B': 'Waterfront Station',
            'C': 'Granville Street',
            'D': 'Vancouver Art Gallery',
            'E': 'Yaletown',
            'F': 'Library Square'
        };

        // Mock City Data - Edges (streets with component scores and realistic paths)
        const edges = [
            { 
                from: 'A', to: 'B', distance: 1, 
                scores: { infra: 8, light: 9, crime: 2, disruption: 0, amenity: 8 },
                path: [
                    [49.2827, -123.1207], // Node A
                    [49.2823, -123.1200],
                    [49.2818, -123.1195],
                    [49.2810, -123.1190]  // Node B
                ]
            },
            { 
                from: 'B', to: 'C', distance: 1, 
                scores: { infra: 4, light: 3, crime: 8, disruption: 0, amenity: 2 },
                path: [
                    [49.2810, -123.1190], // Node B
                    [49.2800, -123.1200],
                    [49.2790, -123.1215],
                    [49.2780, -123.1230]  // Node C
                ]
            },
            { 
                from: 'A', to: 'C', distance: 2, 
                scores: { infra: 6, light: 5, crime: 5, disruption: 0, amenity: 0 },
                path: [
                    [49.2827, -123.1207], // Node A
                    [49.2815, -123.1215],
                    [49.2800, -123.1220],
                    [49.2780, -123.1230]  // Node C
                ]
            },
            { 
                from: 'B', to: 'D', distance: 2, 
                scores: { infra: 9, light: 8, crime: 3, disruption: 0, amenity: 5 },
                path: [
                    [49.2810, -123.1190], // Node B
                    [49.2805, -123.1210],
                    [49.2800, -123.1230],
                    [49.2790, -123.1250]  // Node D
                ]
            },
            { 
                from: 'C', to: 'D', distance: 1, 
                scores: { infra: 3, light: 2, crime: 9, disruption: 10, amenity: 1 }, // Bad route
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2785, -123.1240],
                    [49.2790, -123.1250]  // Node D
                ]
            },
            { 
                from: 'C', to: 'E', distance: 3, 
                scores: { infra: 7, light: 7, crime: 4, disruption: 0, amenity: 3 },
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2775, -123.1245],
                    [49.2770, -123.1260],
                    [49.2765, -123.1270],
                    [49.2760, -123.1280]  // Node E
                ]
            },
            { 
                from: 'D', to: 'E', distance: 1, 
                scores: { infra: 8, light: 9, crime: 2, disruption: 0, amenity: 7 },
                path: [
                    [49.2790, -123.1250], // Node D
                    [49.2780, -123.1265],
                    [49.2770, -123.1275],
                    [49.2760, -123.1280]  // Node E
                ]
            },
            { 
                from: 'E', to: 'F', distance: 2, 
                scores: { infra: 9, light: 9, crime: 1, disruption: 0, amenity: 9 }, // Very safe
                path: [
                    [49.2760, -123.1280], // Node E
                    [49.2755, -123.1250],
                    [49.2750, -123.1225],
                    [49.2745, -123.1210],
                    [49.2740, -123.1200]  // Node F
                ]
            },
            { 
                from: 'C', to: 'F', distance: 2, 
                scores: { infra: 5, light: 6, crime: 6, disruption: 0, amenity: 4 },
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2770, -123.1220],
                    [49.2760, -123.1210],
                    [49.2750, -123.1205],
                    [49.2740, -123.1200]  // Node F
                ]
            }
        ];

        // Global map variable
        let map;
        let fastestRouteLayer = null;
        let safestRouteLayer = null;
        let routeMarkers = [];

        // Format time for display
        function formatTime(hour) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
            return `${displayHour}:00 ${period}`;
        }

        // Dijkstra's Algorithm
        function findShortestPath(graph, startNode, endNode) {
            const distances = {};
            const previous = {};
            const unvisited = new Set();
            const visited = new Set();

            // Initialize distances
            for (const node in graph) {
                distances[node] = Infinity;
                previous[node] = null;
                unvisited.add(node);
            }
            distances[startNode] = 0;

            while (unvisited.size > 0) {
                // Find the unvisited node with the smallest distance
                let currentNode = null;
                let smallestDistance = Infinity;
                
                for (const node of unvisited) {
                    if (distances[node] < smallestDistance) {
                        smallestDistance = distances[node];
                        currentNode = node;
                    }
                }

                if (currentNode === null || distances[currentNode] === Infinity) {
                    break; // No path exists
                }

                if (currentNode === endNode) {
                    // Reconstruct path
                    const path = [];
                    let node = endNode;
                    while (node !== null) {
                        path.unshift(node);
                        node = previous[node];
                    }
                    return path;
                }

                unvisited.delete(currentNode);
                visited.add(currentNode);

                // Update distances to neighbors
                if (graph[currentNode]) {
                    for (const neighbor in graph[currentNode]) {
                        if (visited.has(neighbor)) continue;

                        const alt = distances[currentNode] + graph[currentNode][neighbor];
                        if (alt < distances[neighbor]) {
                            distances[neighbor] = alt;
                            previous[neighbor] = currentNode;
                        }
                    }
                }
            }

            return []; // No path found
        }

        // Build Graph for Fastest Route (distance only)
        function buildGraph_Fastest() {
            const graph = {};
            
            for (const edge of edges) {
                const cost = edge.distance;

                // Add to graph (bidirectional)
                if (!graph[edge.from]) {
                    graph[edge.from] = {};
                }
                if (!graph[edge.to]) {
                    graph[edge.to] = {};
                }
                graph[edge.from][edge.to] = cost;
                graph[edge.to][edge.from] = cost;
            }

            return graph;
        }

        // Build Graph with Time-of-Day Logic (for safest route)
        function buildGraph(currentHour) {
            const graph = {};
            const hour = parseInt(currentHour);

            // Apply Time-of-Day Logic
            let lightWeight = W_LIGHTING;
            let crimeWeight = W_CRIME;
            const isDayTime = (hour > 6 && hour < 19);

            if (isDayTime) {
                lightWeight = 0.1; // Lights don't matter in the day
            } else {
                crimeWeight = crimeWeight * 1.5; // Crime is worse at night
            }

            // Build adjacency list
            for (const edge of edges) {
                const scores = edge.scores;

                // Calculate safety score (high is good)
                const safetyScore = (W_INFRASTRUCTURE * scores.infra) +
                                  (lightWeight * scores.light) +
                                  (W_AMENITY * scores.amenity) +
                                  (crimeWeight * scores.crime) +
                                  (W_DISRUPTION * scores.disruption);

                // Calculate final cost (low is good for Dijkstra's)
                // Base cost is distance. A "safer" route feels shorter.
                const cost = edge.distance - (safetyScore * 0.1);
                // Ensure cost is never negative
                const finalCost = Math.max(0.1, cost);

                // Add to graph (bidirectional)
                if (!graph[edge.from]) {
                    graph[edge.from] = {};
                }
                if (!graph[edge.to]) {
                    graph[edge.to] = {};
                }
                graph[edge.from][edge.to] = finalCost;
                graph[edge.to][edge.from] = finalCost;
            }

            return graph;
        }

        // Draw Route on Map using realistic paths from edges
        function drawRoute(pathNodeIds, color) {
            if (!pathNodeIds || pathNodeIds.length === 0) {
                return null;
            }

            // Build complete path from edge paths
            let fullPathLatLngs = [];
            
            for (let i = 0; i < pathNodeIds.length - 1; i++) {
                const a = pathNodeIds[i];
                const b = pathNodeIds[i + 1];
                
                // Find the edge
                let edge = edges.find(e => 
                    (e.from === a && e.to === b) || (e.from === b && e.to === a)
                );
                
                if (edge && edge.path) {
                    let edgePath = [...edge.path];
                    
                    // If edge is reversed, reverse the path
                    if (edge.from === b && edge.to === a) {
                        edgePath = edgePath.reverse();
                    }
                    
                    // Add path points (skip first point if not the first edge to avoid duplicates)
                    if (i === 0) {
                        fullPathLatLngs.push(...edgePath);
                    } else {
                        fullPathLatLngs.push(...edgePath.slice(1)); // Skip first point
                    }
                }
            }

            if (fullPathLatLngs.length === 0) {
                return null;
            }

            // Create polyline
            const polyline = L.polyline(fullPathLatLngs, {
                color: color,
                weight: 6,
                opacity: 0.7
            }).addTo(map);

            return polyline;
        }

        // Calculate Path Metrics
        function calculatePathMetrics(pathNodeIds, currentHour) {
            if (!pathNodeIds || pathNodeIds.length === 0) {
                return null;
            }

            let totalDistance = 0;
            let totalInfra = 0;
            let totalLight = 0;
            let totalCrime = 0;
            let totalDisruption = 0;
            let totalAmenity = 0;
            let edgeCount = 0;

            // Sum up all edge metrics
            for (let i = 0; i < pathNodeIds.length - 1; i++) {
                const a = pathNodeIds[i];
                const b = pathNodeIds[i + 1];
                
                const edge = edges.find(e => 
                    (e.from === a && e.to === b) || (e.from === b && e.to === a)
                );
                
                if (edge) {
                    totalDistance += edge.distance;
                    totalInfra += edge.scores.infra;
                    totalLight += edge.scores.light;
                    totalCrime += edge.scores.crime;
                    totalDisruption += edge.scores.disruption;
                    totalAmenity += edge.scores.amenity;
                    edgeCount++;
                }
            }

            // Calculate averages
            const avgInfra = edgeCount > 0 ? totalInfra / edgeCount : 0;
            const avgLight = edgeCount > 0 ? totalLight / edgeCount : 0;
            const avgCrime = edgeCount > 0 ? totalCrime / edgeCount : 0;
            const avgDisruption = edgeCount > 0 ? totalDisruption / edgeCount : 0;
            const avgAmenity = edgeCount > 0 ? totalAmenity / edgeCount : 0;

            // Calculate safety score using time-of-day logic
            const hour = parseInt(currentHour);
            let lightWeight = W_LIGHTING;
            let crimeWeight = W_CRIME;
            const isDayTime = (hour > 6 && hour < 19);

            if (isDayTime) {
                lightWeight = 0.1;
            } else {
                crimeWeight = crimeWeight * 1.5;
            }

            const safetyScore = (W_INFRASTRUCTURE * avgInfra) +
                              (lightWeight * avgLight) +
                              (W_AMENITY * avgAmenity) +
                              (crimeWeight * avgCrime) +
                              (W_DISRUPTION * avgDisruption);

            // Normalize to 0-100 scale
            const normalizedScore = Math.max(0, Math.min(100, Math.round(50 + safetyScore)));

            return {
                distance: totalDistance.toFixed(1),
                safetyScore: normalizedScore,
                infra: avgInfra.toFixed(1),
                light: avgLight.toFixed(1),
                crime: avgCrime.toFixed(1),
                disruption: avgDisruption.toFixed(1),
                amenity: avgAmenity.toFixed(1)
            };
        }

        // Update All Routes (Main Function)
        function updateAllRoutes() {
            const startNode = document.getElementById('start-node').value;
            const endNode = document.getElementById('end-node').value;
            const hour = parseInt(document.getElementById('time-slider').value);

            // Clear old routes
            if (fastestRouteLayer) {
                map.removeLayer(fastestRouteLayer);
                fastestRouteLayer = null;
            }
            if (safestRouteLayer) {
                map.removeLayer(safestRouteLayer);
                safestRouteLayer = null;
            }

            // Remove old markers
            routeMarkers.forEach(marker => map.removeLayer(marker));
            routeMarkers = [];

            if (startNode === endNode || !startNode || !endNode) {
                document.getElementById('details-panel').innerHTML = '<p class="text-gray-300">Please select different start and end locations.</p>';
                return;
            }

            // Find Fastest Path
            const graph_fast = buildGraph_Fastest();
            const fastestPathNodes = findShortestPath(graph_fast, startNode, endNode);

            // Find Safest Path
            const graph_safe = buildGraph(hour);
            const safestPathNodes = findShortestPath(graph_safe, startNode, endNode);

            // Draw both paths
            if (fastestPathNodes.length > 0) {
                fastestRouteLayer = drawRoute(fastestPathNodes, 'blue');
            }
            if (safestPathNodes.length > 0) {
                safestRouteLayer = drawRoute(safestPathNodes, 'green');
            }

            // Add markers for start and end
            if (nodes[startNode] && nodes[endNode]) {
                const startMarker = L.marker(nodes[startNode]).addTo(map)
                    .bindPopup(`Start: ${nodeNames[startNode]} (${startNode})`);
                const endMarker = L.marker(nodes[endNode]).addTo(map)
                    .bindPopup(`End: ${nodeNames[endNode]} (${endNode})`);
                routeMarkers.push(startMarker, endMarker);

                // Fit map to show both routes
                const bounds = L.latLngBounds([nodes[startNode], nodes[endNode]]);
                if (fastestRouteLayer) {
                    bounds.extend(fastestRouteLayer.getBounds());
                }
                if (safestRouteLayer) {
                    bounds.extend(safestRouteLayer.getBounds());
                }
                map.fitBounds(bounds, { padding: [50, 50] });
            }

            // Calculate metrics
            const fastestMetrics = calculatePathMetrics(fastestPathNodes, hour);
            const safestMetrics = calculatePathMetrics(safestPathNodes, hour);

            // Update details panel
            const detailsPanel = document.getElementById('details-panel');
            const isDayTime = (hour >= 6 && hour < 19);

            if (fastestMetrics && safestMetrics) {
                const fastestScoreColor = fastestMetrics.safetyScore >= 70 ? 'text-green-400' : fastestMetrics.safetyScore >= 50 ? 'text-yellow-400' : 'text-red-400';
                const safestScoreColor = safestMetrics.safetyScore >= 70 ? 'text-green-400' : safestMetrics.safetyScore >= 50 ? 'text-yellow-400' : 'text-red-400';

                detailsPanel.innerHTML = `
                    <div class="p-4 bg-green-800 rounded-lg mb-4">
                        <h3 class="text-lg font-bold text-green-400 mb-2">üõ°Ô∏è Safest Route</h3>
                        <div class="text-2xl font-bold ${safestScoreColor} mb-2">
                            ${safestMetrics.safetyScore} <span class="text-sm text-white">/ 100</span>
                        </div>
                        <p class="text-sm text-gray-300">Distance: <span class="font-semibold">${safestMetrics.distance} km</span></p>
                        <div class="mt-2 text-xs text-gray-400 space-y-1">
                            <p>Infrastructure: ${safestMetrics.infra} | Lighting: ${safestMetrics.light} | Crime: ${safestMetrics.crime}</p>
                            <p>Safe Havens: ${safestMetrics.amenity} | Disruptions: ${safestMetrics.disruption}</p>
                        </div>
                    </div>
                    <div class="p-4 bg-blue-800 rounded-lg">
                        <h3 class="text-lg font-bold text-blue-300 mb-2">‚ö° Fastest Route</h3>
                        <div class="text-2xl font-bold ${fastestScoreColor} mb-2">
                            ${fastestMetrics.safetyScore} <span class="text-sm text-white">/ 100</span>
                        </div>
                        <p class="text-sm text-gray-300">Distance: <span class="font-semibold">${fastestMetrics.distance} km</span></p>
                        <div class="mt-2 text-xs text-gray-400 space-y-1">
                            <p>Infrastructure: ${fastestMetrics.infra} | Lighting: ${fastestMetrics.light} | Crime: ${fastestMetrics.crime}</p>
                            <p>Safe Havens: ${fastestMetrics.amenity} | Disruptions: ${fastestMetrics.disruption}</p>
                        </div>
                    </div>
                    <div class="mt-4 pt-4 border-t border-blue-700">
                        <p class="text-xs text-gray-400">
                            ${isDayTime ? '‚òÄÔ∏è Daytime: Lighting has minimal impact' : 'üåô Nighttime: Crime risk is weighted higher'}
                        </p>
                    </div>
                `;
            } else {
                detailsPanel.innerHTML = '<p class="text-red-400">No route found</p>';
            }
        }

        // Populate Node Dropdowns
        function populateNodeDropdowns() {
            const startSelect = document.getElementById('start-node');
            const endSelect = document.getElementById('end-node');

            // Clear existing options
            startSelect.innerHTML = '<option value="">Select start location...</option>';
            endSelect.innerHTML = '<option value="">Select end location...</option>';

            // Add options for each node
            for (const nodeId in nodes) {
                const optionText = `${nodeNames[nodeId]} (${nodeId})`;
                const startOption = document.createElement('option');
                startOption.value = nodeId;
                startOption.textContent = optionText;
                startSelect.appendChild(startOption);

                const endOption = document.createElement('option');
                endOption.value = nodeId;
                endOption.textContent = optionText;
                endSelect.appendChild(endOption);
            }

            // Set default values
            startSelect.value = 'A';
            endSelect.value = 'F';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Leaflet map
            map = L.map('map').setView([49.28, -123.12], 14);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Populate node dropdowns
            populateNodeDropdowns();

            // Initialize time slider
            const slider = document.getElementById('time-slider');
            const timeLabel = document.getElementById('time-label');
            const startSelect = document.getElementById('start-node');
            const endSelect = document.getElementById('end-node');
            const currentHour = new Date().getHours();

            // Set slider to current hour
            slider.value = currentHour;
            timeLabel.textContent = formatTime(currentHour);

            // Add event listeners
            slider.addEventListener('input', function() {
                const hour = parseInt(this.value);
                timeLabel.textContent = formatTime(hour);
                updateAllRoutes();
            });

            startSelect.addEventListener('change', updateAllRoutes);
            endSelect.addEventListener('change', updateAllRoutes);

            // Draw initial route
            updateAllRoutes();
        });
    </script>
</body>
</html>
