<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SafeWalk+</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f3f4f6;
        }
        
        #map {
            z-index: 1;
        }
        
        /* Glassmorphism Panel */
        #control-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            max-height: 75vh;
            z-index: 1000;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            
            /* Glassmorphism effect */
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3), 
                        0 0 0 1px rgba(255, 255, 255, 0.5) inset;
        }
        
        /* Minimized state - small and horizontal */
        #control-panel.minimized {
            width: 90%;
            max-width: 800px;
            padding: 16px 24px;
            max-height: none;
        }
        
        #control-panel.minimized .panel-title,
        #control-panel.minimized .time-section,
        #control-panel.minimized .route-section {
            display: none;
        }
        
        #control-panel.minimized .search-inputs-container {
            display: flex;
            gap: 16px;
            align-items: flex-end;
        }
        
        #control-panel.minimized .search-inputs-container > div {
            flex: 1;
        }
        
        #control-panel.minimized .input-label {
            font-size: 11px;
            margin-bottom: 6px;
        }
        
        #control-panel.minimized .search-input {
            padding: 10px 14px;
            font-size: 14px;
        }
        
        /* Expanded state */
        #control-panel:not(.minimized) .search-inputs-container {
            display: block;
        }
        
        #control-panel:not(.minimized) .search-inputs-container > div {
            margin-bottom: 20px;
        }
        
        #control-panel.slide-to-side {
            left: 24px;
            top: 24px;
            bottom: auto;
            transform: translateX(0);
            width: 420px;
            max-width: 420px;
            max-height: calc(100vh - 48px);
            border-radius: 20px;
        }
        
        #control-panel.slide-to-side.minimized {
            width: 420px;
            max-width: 420px;
        }
        
        /* Modern Input Styling */
        .search-input {
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
            padding: 14px 16px;
            font-size: 15px;
            transition: all 0.3s ease;
            color: #1a1a1a;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }
        
        .search-input::placeholder {
            color: #9ca3af;
        }
        
        /* Search Results Dropdown */
        .search-results {
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }
        
        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #1a1a1a;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .search-result-item:last-child {
            border-bottom: none;
        }
        
        .search-result-item:hover {
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transform: translateX(4px);
        }
        
        /* Time Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 10px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            outline: none;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.6);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        /* Route Card Styling */
        .route-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            transition: all 0.3s ease;
        }
        
        .route-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.2);
        }
        
        .route-card.safest {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(22, 163, 74, 0.15));
            border-color: rgba(34, 197, 94, 0.3);
        }
        
        .route-card.fastest {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.15));
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        .safety-score {
            font-size: 48px;
            font-weight: 800;
            line-height: 1;
            margin: 12px 0;
        }
        
        .metric-badge {
            display: inline-flex;
            align-items: center;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            margin: 4px 4px 4px 0;
            color: #4b5563;
        }
        
        /* Label Styling */
        .input-label {
            font-weight: 600;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #4b5563;
            margin-bottom: 8px;
            display: block;
        }
        
        /* Title Styling */
        .panel-title {
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 24px;
            letter-spacing: -0.5px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 700;
            color: #1a1a1a;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Time Display */
        .time-display {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* Details Panel */
        #details-panel {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 16px;
            padding: 20px;
            min-height: 200px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
            font-size: 15px;
        }
        
        @media (max-width: 768px) {
            #control-panel {
                width: calc(100% - 32px);
                bottom: 16px;
            }
            
            #control-panel.minimized {
                width: calc(100% - 32px);
                padding: 12px 16px;
            }
            
            #control-panel.minimized .search-inputs-container {
                flex-direction: column;
                gap: 12px;
            }
            
            #control-panel.slide-to-side {
                width: calc(100% - 32px);
                max-width: none;
                left: 16px;
                top: 16px;
            }
            
            #control-panel.slide-to-side.minimized {
                width: calc(100% - 32px);
            }
            
            .panel-title {
                font-size: 24px;
            }
        }
        
        /* Smooth fade-in animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .route-card {
            animation: fadeIn 0.4s ease-out;
        }
    </style>
</head>
<body class="h-screen overflow-hidden">
    <!-- Main Content Area (Map) -->
    <div class="h-full w-full relative overflow-hidden">
        <div id="map" class="h-full w-full"></div>
    </div>
    
    <!-- Floating Control Panel -->
    <div id="control-panel" class="minimized p-8 overflow-y-auto">
        <h1 class="panel-title">üõ°Ô∏è SafeWalk+</h1>
            
            <!-- Route Inputs -->
        <div class="search-inputs-container">
                <div>
                <label for="start-node" class="input-label">üìç Start Location</label>
                <div class="relative">
                    <input 
                        type="text" 
                        id="start-node" 
                        placeholder="Search for a location..."
                        class="search-input w-full"
                        autocomplete="off"
                    >
                    <div id="start-node-results" class="search-results absolute z-50 w-full mt-2 max-h-60 overflow-y-auto hidden"></div>
                </div>
                </div>
                <div>
                <label for="end-node" class="input-label">üéØ End Location</label>
                <div class="relative">
                    <input 
                        type="text" 
                        id="end-node" 
                        placeholder="Search for a location..."
                        class="search-input w-full"
                        autocomplete="off"
                    >
                    <div id="end-node-results" class="search-results absolute z-50 w-full mt-2 max-h-60 overflow-y-auto hidden"></div>
                </div>
                </div>
            </div>

            <!-- Time Slider -->
        <div class="time-section mb-6">
            <label class="input-label">
                ‚è∞ Time of Day: <span id="time-label" class="time-display">12:00 PM</span>
                </label>
                <input 
                    type="range" 
                    id="time-slider" 
                    min="0" 
                    max="23" 
                    value="12" 
                class="w-full mt-3"
                >
            </div>

            <!-- Route Details Panel -->
        <div class="route-section mt-6">
            <h2 class="section-title">Route Analysis</h2>
            <div id="details-panel">
                <div class="empty-state">
                    <p>Select start and end locations to see route details</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Scoring Weights
        const W_INFRASTRUCTURE = 2.5;
        const W_LIGHTING = 2.0;
        const W_AMENITY = 1.5;
        const W_CRIME = -3.0;
        const W_DISRUPTION = -2.0;

        // Mock City Data - Nodes (locations in Vancouver)
        const nodes = {
            'A': [49.2827, -123.1207], // Gastown
            'B': [49.2810, -123.1190], // Waterfront Station
            'C': [49.2780, -123.1230], // Granville Street
            'D': [49.2790, -123.1250], // Vancouver Art Gallery
            'E': [49.2760, -123.1280], // Yaletown
            'F': [49.2740, -123.1200]  // Library Square
        };

        // Node names for display
        const nodeNames = {
            'A': 'Gastown',
            'B': 'Waterfront Station',
            'C': 'Granville Street',
            'D': 'Vancouver Art Gallery',
            'E': 'Yaletown',
            'F': 'Library Square'
        };

        /**
         * Mock City Data - Edges (streets with component scores and realistic paths)
         * 
         * NOTE: These initial scores are PLACEHOLDERS. They will be recalculated
         * when CSV data loads via calculateEdgeScores(). The initial scores ensure
         * the app works before CSV data loads, but real safety scores come from CSV.
         * 
         * Each edge has:
         * - from/to: Node IDs
         * - distance: Physical distance in km (used for FASTEST path)
         * - scores: Safety component scores (used for SAFEST path after CSV processing)
         * - path: Array of [lat, lon] coordinates for drawing the route
         * 
         * IMPORTANT: Distance and safety are INDEPENDENT. A short route can be unsafe,
         * and a long route can be safe. This ensures fastest and safest paths differ.
         */
        const edges = [
            { 
                from: 'A', to: 'B', distance: 1, 
                scores: { infra: 8, light: 9, crime: 2, disruption: 0, amenity: 8 },
                description: "Well-lit historic Gastown area with active street life and nearby fire hall",
                path: [
                    [49.2827, -123.1207], // Node A
                    [49.2823, -123.1200],
                    [49.2818, -123.1195],
                    [49.2810, -123.1190]  // Node B
                ]
            },
            { 
                from: 'B', to: 'C', distance: 1, 
                scores: { infra: 4, light: 3, crime: 8, disruption: 0, amenity: 2 },
                description: "‚ö†Ô∏è Passes through East Hastings - high crime area, poor lighting, avoid at night",
                path: [
                    [49.2810, -123.1190], // Node B
                    [49.2800, -123.1200],
                    [49.2790, -123.1215],
                    [49.2780, -123.1230]  // Node C
                ]
            },
            { 
                from: 'A', to: 'C', distance: 2, 
                scores: { infra: 6, light: 5, crime: 5, disruption: 0, amenity: 0 },
                description: "Mixed commercial area, moderate safety, limited safe havens",
                path: [
                    [49.2827, -123.1207], // Node A
                    [49.2815, -123.1215],
                    [49.2800, -123.1220],
                    [49.2780, -123.1230]  // Node C
                ]
            },
            { 
                from: 'B', to: 'D', distance: 2, 
                scores: { infra: 9, light: 8, crime: 3, disruption: 0, amenity: 5 },
                description: "‚úÖ Safe route through downtown core with excellent infrastructure and lighting",
                path: [
                    [49.2810, -123.1190], // Node B
                    [49.2805, -123.1210],
                    [49.2800, -123.1230],
                    [49.2790, -123.1250]  // Node D
                ]
            },
            { 
                from: 'C', to: 'D', distance: 1, 
                scores: { infra: 3, light: 2, crime: 9, disruption: 10, amenity: 1 }, // Bad route
                description: "‚ùå AVOID: High crime area with active road closures and construction",
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2785, -123.1240],
                    [49.2790, -123.1250]  // Node D
                ]
            },
            { 
                from: 'C', to: 'E', distance: 3, 
                scores: { infra: 7, light: 7, crime: 4, disruption: 0, amenity: 3 },
                description: "Longer route through residential Yaletown, good sidewalks and lighting",
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2775, -123.1245],
                    [49.2770, -123.1260],
                    [49.2765, -123.1270],
                    [49.2760, -123.1280]  // Node E
                ]
            },
            { 
                from: 'D', to: 'E', distance: 1, 
                scores: { infra: 8, light: 9, crime: 2, disruption: 0, amenity: 7 },
                description: "‚úÖ Excellent route: Well-lit path through Yaletown with parks and safe havens nearby",
                path: [
                    [49.2790, -123.1250], // Node D
                    [49.2780, -123.1265],
                    [49.2770, -123.1275],
                    [49.2760, -123.1280]  // Node E
                ]
            },
            { 
                from: 'E', to: 'F', distance: 2, 
                scores: { infra: 9, light: 9, crime: 1, disruption: 0, amenity: 9 }, // Very safe
                description: "‚úÖ SAFEST: Route through parks and quiet neighborhoods with fire hall access",
                path: [
                    [49.2760, -123.1280], // Node E
                    [49.2755, -123.1250],
                    [49.2750, -123.1225],
                    [49.2745, -123.1210],
                    [49.2740, -123.1200]  // Node F
                ]
            },
            { 
                from: 'C', to: 'F', distance: 2, 
                scores: { infra: 5, light: 6, crime: 6, disruption: 0, amenity: 4 },
                description: "Direct route but passes through areas with moderate crime and limited lighting",
                path: [
                    [49.2780, -123.1230], // Node C
                    [49.2770, -123.1220],
                    [49.2760, -123.1210],
                    [49.2750, -123.1205],
                    [49.2740, -123.1200]  // Node F
                ]
            }
        ];

        // Global map variable
        let map;
        let fastestRouteLayer = null;
        let safestRouteLayer = null;
        let routeMarkers = [];
        let panelAnimated = false;
        
        // CSV Data Storage
        let lightingData = [];
        let crimeData = [];
        let bikewayData = [];
        let closureData = [];
        let fireHallData = [];
        let sidewalkData = [];
        let csvDataLoaded = false;

        // Format time for display
        function formatTime(hour) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
            return `${displayHour}:00 ${period}`;
        }

        // Calculate distance between two lat/lng points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Parse coordinates from geo_point_2d or Geom field
        function parseCoordinates(row, isCrimeData = false) {
            let lat, lon;
            
            // For crime data, try HUNDRED_BLOCK and NEIGHBOURHOOD to get approximate location
            // For now, skip crime data coordinates as they use a different system
            if (isCrimeData && row['X'] && row['Y']) {
                // X, Y appear to be in UTM or similar projection
                // Skip for now - we'll use neighbourhood-based approximation if needed
                return null;
            }
            
            // Try geo_point_2d first (format: "lat, lon")
            if (row['geo_point_2d']) {
                const parts = row['geo_point_2d'].split(',');
                if (parts.length === 2) {
                    lat = parseFloat(parts[0].trim());
                    lon = parseFloat(parts[1].trim());
                    if (!isNaN(lat) && !isNaN(lon)) return [lat, lon];
                }
            }
            
            // Try Geom field (JSON format)
            if (row['Geom']) {
                try {
                    const geom = JSON.parse(row['Geom']);
                    if (geom.coordinates) {
                        if (Array.isArray(geom.coordinates[0])) {
                            // LineString or MultiLineString - get first point
                            lon = geom.coordinates[0][0];
                            lat = geom.coordinates[0][1];
                        } else {
                            // Point
                            lon = geom.coordinates[0];
                            lat = geom.coordinates[1];
                        }
                        if (!isNaN(lat) && !isNaN(lon)) return [lat, lon];
                    }
                } catch (e) {
                    // Ignore parse errors
                }
            }
            
            return null;
        }
        
        // Load and parse CSV files
        async function loadCSVData() {
            const csvFiles = [
                { url: '/data/street-lighting-poles.csv', type: 'lighting' },
                { url: '/data/crimedata_csv_AllNeighbourhoods_AllYears.csv', type: 'crime' },
                { url: '/data/bikeways.csv', type: 'bikeway' },
                { url: '/data/road-ahead-current-road-closures.csv', type: 'closure' },
                { url: '/data/fire-halls.csv', type: 'firehall' },
                { url: '/data/sidewalk-condition-rating.csv', type: 'sidewalk' }
            ];
            
            const loadPromises = csvFiles.map(file => {
                return new Promise((resolve, reject) => {
                    // Most files use semicolon, but crime data uses comma
                    const delimiter = file.type === 'crime' ? ',' : ';';
                    Papa.parse(file.url, {
                        download: true,
                        header: true,
                        skipEmptyLines: true,
                        delimiter: delimiter,
                        complete: (results) => {
                            const isCrime = file.type === 'crime';
                            const data = results.data.filter(row => {
                                const coords = parseCoordinates(row, isCrime);
                                return coords !== null;
                            }).map(row => ({
                                ...row,
                                coords: parseCoordinates(row, isCrime)
                            }));
                            
                            switch(file.type) {
                                case 'lighting':
                                    lightingData = data;
                                    break;
                                case 'crime':
                                    crimeData = data;
                                    break;
                                case 'bikeway':
                                    bikewayData = data;
                                    break;
                                case 'closure':
                                    closureData = data;
                                    break;
                                case 'firehall':
                                    fireHallData = data;
                                    break;
                                case 'sidewalk':
                                    sidewalkData = data;
                                    break;
                            }
                            resolve();
                        },
                        error: (error) => {
                            console.warn(`Failed to load ${file.url}:`, error);
                            resolve(); // Continue even if one file fails
                        }
                    });
                });
            });
            
            await Promise.all(loadPromises);
            csvDataLoaded = true;
            calculateEdgeScores();
        }
        
        /**
         * Calculate safety scores for each edge based on CSV data.
         * Safety scoring follows this formula:
         * - Sidewalk present ‚Üí +2
         * - Streetlight present ‚Üí +1  
         * - Low traffic (no closures) ‚Üí +1
         * - Crime nearby ‚Üí negative impact
         * 
         * These scores are used ONLY for the safest path calculation.
         * Distance is calculated separately for the fastest path.
         */
        function calculateEdgeScores() {
            if (!csvDataLoaded) return;
            
            edges.forEach(edge => {
                let totalSafetyScore = 0;
                let pointCount = 0;
                
                // Check each point along the path
                edge.path.forEach(point => {
                    const [lat, lon] = point;
                    let pointSafetyScore = 0; // Start with 0, add points for safety features
                    
                    // SIDEWALK: Check for sidewalks nearby (within 50m)
                    // Sidewalk present ‚Üí +2 points
                    let hasSidewalk = false;
                    sidewalkData.forEach(sidewalk => {
                        if (sidewalk.coords) {
                            const dist = calculateDistance(lat, lon, sidewalk.coords[0], sidewalk.coords[1]) * 1000;
                            if (dist < 50) {
                                const condition = sidewalk['Sidewalk Condition Index Rating'];
                                // Only count if sidewalk is in good condition
                                if (condition === 'Very Good' || condition === 'Good' || condition === 'Fair') {
                                    hasSidewalk = true;
                                }
                            }
                        }
                    });
                    if (hasSidewalk) {
                        pointSafetyScore += 2;
                    }
                    
                    // STREETLIGHT: Count nearby lighting poles (within 150m)
                    // Streetlight present ‚Üí +1 point (at least one light nearby)
                    let hasStreetlight = false;
                    lightingData.forEach(light => {
                        if (light.coords) {
                            const dist = calculateDistance(lat, lon, light.coords[0], light.coords[1]) * 1000;
                            if (dist < 150) {
                                hasStreetlight = true;
                            }
                        }
                    });
                    if (hasStreetlight) {
                        pointSafetyScore += 1;
                    }
                    
                    // LOW TRAFFIC: Check for road closures (no closures = low traffic)
                    // Low traffic (no closures) ‚Üí +1 point
                    let hasClosure = false;
                    closureData.forEach(closure => {
                        if (closure.coords) {
                            const dist = calculateDistance(lat, lon, closure.coords[0], closure.coords[1]) * 1000;
                            if (dist < 100) {
                                hasClosure = true;
                            }
                        }
                    });
                    if (!hasClosure) {
                        pointSafetyScore += 1; // No closure = low traffic = safer
                    }
                    
                    // CRIME: Negative impact (more crime = lower safety)
                    // Count crimes nearby (within 500m)
                    let crimeCount = 0;
                    crimeData.forEach(crime => {
                        if (crime.coords) {
                            const dist = calculateDistance(lat, lon, crime.coords[0], crime.coords[1]) * 1000;
                            if (dist < 500) {
                                crimeCount++;
                            }
                        }
                    });
                    // Penalize for crime: -0.5 per crime (capped at -3)
                    pointSafetyScore -= Math.min(3, crimeCount * 0.5);
                    
                    // BIKEWAYS: Bonus for bike infrastructure (indicates pedestrian-friendly area)
                    bikewayData.forEach(bikeway => {
                        if (bikeway.coords) {
                            const dist = calculateDistance(lat, lon, bikeway.coords[0], bikeway.coords[1]) * 1000;
                            if (dist < 100) {
                                pointSafetyScore += 0.5; // Bonus for bike infrastructure
                            }
                        }
                    });
                    
                    // FIRE HALLS: Safe havens nearby
                    fireHallData.forEach(firehall => {
                        if (firehall.coords) {
                            const dist = calculateDistance(lat, lon, firehall.coords[0], firehall.coords[1]) * 1000;
                            if (dist < 500) {
                                pointSafetyScore += 0.5; // Bonus for safe haven nearby
                            }
                        }
                    });
                    
                    // Ensure safety score is non-negative and capped at reasonable max
                    pointSafetyScore = Math.max(0, Math.min(10, pointSafetyScore));
                    
                    totalSafetyScore += pointSafetyScore;
                    pointCount++;
                });
                
                // Calculate average safety score for this edge
                // Also store individual components for display
                if (pointCount > 0) {
                    const avgSafety = totalSafetyScore / pointCount;
                    
                    // Store both the combined safety score and individual components
                    edge.safetyScore = Math.round(avgSafety * 10) / 10;
                    
                    // Keep detailed scores for display purposes
                    edge.scores = {
                        safety: edge.safetyScore,
                        // For backwards compatibility with display code
                        infra: edge.safetyScore * 0.4, // Approximate mapping
                        light: edge.safetyScore * 0.3,
                        crime: Math.max(0, 10 - edge.safetyScore),
                        disruption: 0,
                        amenity: edge.safetyScore * 0.3
                    };
                } else {
                    // Fallback to default scores if no points
                    edge.safetyScore = 2; // Default moderate safety
                    edge.scores = { 
                        safety: 2,
                        infra: 5, 
                        light: 5, 
                        crime: 5, 
                        disruption: 0, 
                        amenity: 0 
                    };
                }
            });
        }

        /**
         * Dijkstra's Algorithm for Pathfinding
         * 
         * This algorithm finds the shortest path in a weighted graph.
         * It's used for BOTH fastest and safest paths:
         * - For FASTEST path: graph weights = distance
         * - For SAFEST path: graph weights = inverted safety scores
         * 
         * The algorithm works the same way for both - it just uses different edge weights.
         * This ensures routes are calculated independently based on their respective criteria.
         * 
         * @param {Object} graph - Adjacency list with edge weights
         * @param {string} startNode - Starting node ID
         * @param {string} endNode - Ending node ID
         * @returns {Array} Array of node IDs representing the path, or empty array if no path
         */
        function findShortestPath(graph, startNode, endNode) {
            const distances = {};
            const previous = {};
            const unvisited = new Set();
            const visited = new Set();

            // Initialize distances
            for (const node in graph) {
                distances[node] = Infinity;
                previous[node] = null;
                unvisited.add(node);
            }
            distances[startNode] = 0;

            while (unvisited.size > 0) {
                // Find the unvisited node with the smallest distance
                let currentNode = null;
                let smallestDistance = Infinity;
                
                for (const node of unvisited) {
                    if (distances[node] < smallestDistance) {
                        smallestDistance = distances[node];
                        currentNode = node;
                    }
                }

                if (currentNode === null || distances[currentNode] === Infinity) {
                    break; // No path exists
                }

                if (currentNode === endNode) {
                    // Reconstruct path
                    const path = [];
                    let node = endNode;
                    while (node !== null) {
                        path.unshift(node);
                        node = previous[node];
                    }
                    return path;
                }

                unvisited.delete(currentNode);
                visited.add(currentNode);

                // Update distances to neighbors
                if (graph[currentNode]) {
                    for (const neighbor in graph[currentNode]) {
                        if (visited.has(neighbor)) continue;

                        const alt = distances[currentNode] + graph[currentNode][neighbor];
                        if (alt < distances[neighbor]) {
                            distances[neighbor] = alt;
                            previous[neighbor] = currentNode;
                        }
                    }
                }
            }

            return []; // No path found
        }

        /**
         * Build Graph for FASTEST Route - Distance Only
         * 
         * This function creates a graph where edge weights are PURELY based on distance.
         * No safety considerations are included here. This ensures the fastest path
         * minimizes travel distance/time regardless of safety factors.
         * 
         * @returns {Object} Graph with distance-only edge weights
         */
        function buildGraph_Fastest() {
            const graph = {};
            
            for (const edge of edges) {
                // FASTEST PATH: Use ONLY distance as the edge weight
                // This ensures we find the shortest path regardless of safety
                const cost = edge.distance;

                // Add to graph (bidirectional)
                if (!graph[edge.from]) {
                    graph[edge.from] = {};
                }
                if (!graph[edge.to]) {
                    graph[edge.to] = {};
                }
                graph[edge.from][edge.to] = cost;
                graph[edge.to][edge.from] = cost;
            }

            return graph;
        }

        /**
         * Build Graph for SAFEST Route - Safety Weighted
         * 
         * This function creates a graph where edge weights are based on SAFETY SCORES,
         * NOT distance. Higher safety = lower path cost, so Dijkstra will prefer safer routes.
         * 
         * Key principle: Safety and distance are INDEPENDENT. A longer route with high safety
         * can have a lower total cost than a short route with low safety.
         * 
         * Safety scoring:
         * - Sidewalk present ‚Üí +2
         * - Streetlight present ‚Üí +1
         * - Low traffic (no closures) ‚Üí +1
         * - Crime nearby ‚Üí negative impact
         * 
         * The safety score is inverted to create a weight: weight = MAX_SAFETY - safety_score
         * This means higher safety = lower weight = preferred by Dijkstra
         * 
         * @param {number} currentHour - Current hour (0-23) for time-of-day adjustments
         * @returns {Object} Graph with safety-weighted edge costs
         */
        function buildGraph_Safest(currentHour) {
            const graph = {};
            const hour = parseInt(currentHour);

            // Time-of-day adjustments: lighting matters more at night
            const isDayTime = (hour > 6 && hour < 19);
            const lightingMultiplier = isDayTime ? 0.5 : 1.5; // Lights matter more at night
            const crimeMultiplier = isDayTime ? 1.0 : 1.5; // Crime is worse at night

            // Maximum possible safety score (used for inversion)
            const MAX_SAFETY_SCORE = 10;
            
            // Build adjacency list with SAFETY-BASED weights
            for (const edge of edges) {
                // Get the safety score calculated from CSV data
                // If not calculated yet, use a default
                const baseSafetyScore = edge.safetyScore || 2;
                
                // Apply time-of-day adjustments to safety components
                // At night, lighting is more important, crime is worse
                let adjustedSafetyScore = baseSafetyScore;
                
                // If we have detailed scores, adjust them
                if (edge.scores) {
                    // Recalculate with time-of-day weights
                    // This is approximate - the main safety score already includes these factors
                    // But we can adjust the weighting
                    adjustedSafetyScore = baseSafetyScore * (isDayTime ? 0.95 : 1.05);
                }
                
                // INVERT the safety score to create a weight
                // Higher safety = lower weight = preferred path
                // Formula: weight = MAX_SAFETY - safety_score
                // This ensures safer routes have lower costs
                const safetyWeight = MAX_SAFETY_SCORE - adjustedSafetyScore;
                
                // IMPORTANT: For safest path, we use safety weight, NOT distance
                // We add a small base cost to ensure weights are positive and meaningful
                // The base cost is minimal so safety differences dominate
                const baseCost = 0.1; // Minimal base cost
                const cost = baseCost + safetyWeight;

                // Add to graph (bidirectional)
                if (!graph[edge.from]) {
                    graph[edge.from] = {};
                }
                if (!graph[edge.to]) {
                    graph[edge.to] = {};
                }
                graph[edge.from][edge.to] = cost;
                graph[edge.to][edge.from] = cost;
            }

            return graph;
        }
        
        // Alias for backwards compatibility
        function buildGraph(currentHour) {
            return buildGraph_Safest(currentHour);
        }

        // Draw Route on Map using realistic paths from edges
        function drawRoute(pathNodeIds, color) {
            if (!pathNodeIds || pathNodeIds.length === 0) {
                return null;
            }

            // Build complete path from edge paths
            let fullPathLatLngs = [];
            
            for (let i = 0; i < pathNodeIds.length - 1; i++) {
                const a = pathNodeIds[i];
                const b = pathNodeIds[i + 1];
                
                // Find the edge
                let edge = edges.find(e => 
                    (e.from === a && e.to === b) || (e.from === b && e.to === a)
                );
                
                if (edge && edge.path) {
                    let edgePath = [...edge.path];
                    
                    // If edge is reversed, reverse the path
                    if (edge.from === b && edge.to === a) {
                        edgePath = edgePath.reverse();
                    }
                    
                    // Add path points (skip first point if not the first edge to avoid duplicates)
                    if (i === 0) {
                        fullPathLatLngs.push(...edgePath);
                    } else {
                        fullPathLatLngs.push(...edgePath.slice(1)); // Skip first point
                    }
                }
            }

            if (fullPathLatLngs.length === 0) {
                return null;
            }

            // Create polyline
            const polyline = L.polyline(fullPathLatLngs, {
                color: color,
                weight: 6,
                opacity: 0.7
            }).addTo(map);

            return polyline;
        }

        /**
         * Calculate Path Metrics for a given route
         * 
         * This function calculates both distance and safety metrics for a path.
         * It aggregates metrics from all edges in the path.
         * 
         * @param {Array} pathNodeIds - Array of node IDs representing the path
         * @param {number} currentHour - Current hour for time-of-day adjustments
         * @returns {Object} Metrics object with distance, safety score, and component scores
         */
        function calculatePathMetrics(pathNodeIds, currentHour) {
            if (!pathNodeIds || pathNodeIds.length === 0) {
                return null;
            }

            let totalDistance = 0;
            let totalSafetyScore = 0;
            let totalInfra = 0;
            let totalLight = 0;
            let totalCrime = 0;
            let totalDisruption = 0;
            let totalAmenity = 0;
            let edgeCount = 0;
            const pathDescriptions = []; // Collect descriptions from each edge

            // Sum up all edge metrics
            for (let i = 0; i < pathNodeIds.length - 1; i++) {
                const a = pathNodeIds[i];
                const b = pathNodeIds[i + 1];
                
                const edge = edges.find(e => 
                    (e.from === a && e.to === b) || (e.from === b && e.to === a)
                );
                
                if (edge) {
                    totalDistance += edge.distance;
                    
                    // Use the new safetyScore field if available, otherwise use scores
                    if (edge.safetyScore !== undefined) {
                        totalSafetyScore += edge.safetyScore;
                    } else if (edge.scores && edge.scores.safety !== undefined) {
                        totalSafetyScore += edge.scores.safety;
                    } else {
                        // Fallback to calculated safety from scores
                        totalSafetyScore += (edge.scores?.infra || 5) * 0.4;
                    }
                    
                    // Get component scores for display
                    totalInfra += edge.scores?.infra || 5;
                    totalLight += edge.scores?.light || 5;
                    totalCrime += edge.scores?.crime || 5;
                    totalDisruption += edge.scores?.disruption || 0;
                    totalAmenity += edge.scores?.amenity || 0;
                    
                    // Collect description if available
                    if (edge.description) {
                        pathDescriptions.push(edge.description);
                    }
                    
                    edgeCount++;
                }
            }

            // Calculate averages
            const avgSafety = edgeCount > 0 ? totalSafetyScore / edgeCount : 0;
            const avgInfra = edgeCount > 0 ? totalInfra / edgeCount : 0;
            const avgLight = edgeCount > 0 ? totalLight / edgeCount : 0;
            const avgCrime = edgeCount > 0 ? totalCrime / edgeCount : 0;
            const avgDisruption = edgeCount > 0 ? totalDisruption / edgeCount : 0;
            const avgAmenity = edgeCount > 0 ? totalAmenity / edgeCount : 0;

            // Normalize safety score to 0-100 scale for display
            // Safety score is already 0-10, so multiply by 10
            const normalizedScore = Math.max(0, Math.min(100, Math.round(avgSafety * 10)));

            return {
                distance: totalDistance.toFixed(1),
                safetyScore: normalizedScore,
                infra: avgInfra.toFixed(1),
                light: avgLight.toFixed(1),
                crime: avgCrime.toFixed(1),
                disruption: avgDisruption.toFixed(1),
                amenity: avgAmenity.toFixed(1),
                descriptions: pathDescriptions // Include path-specific descriptions
            };
        }

        // Update All Routes (Main Function)
        function updateAllRoutes() {
            const startInput = document.getElementById('start-node');
            const endInput = document.getElementById('end-node');
            const startNode = startInput.dataset.nodeId;
            const endNode = endInput.dataset.nodeId;
            const hour = parseInt(document.getElementById('time-slider').value);

            // Clear old routes
            if (fastestRouteLayer) {
                map.removeLayer(fastestRouteLayer);
                fastestRouteLayer = null;
            }
            if (safestRouteLayer) {
                map.removeLayer(safestRouteLayer);
                safestRouteLayer = null;
            }

            // Remove old markers
            routeMarkers.forEach(marker => map.removeLayer(marker));
            routeMarkers = [];

            if (startNode === endNode || !startNode || !endNode) {
                document.getElementById('details-panel').innerHTML = '<div class="empty-state"><p>Please select different start and end locations.</p></div>';
                return;
            }

            // Find FASTEST Path - Uses distance-only weights
            // This path minimizes total distance regardless of safety
            const graph_fast = buildGraph_Fastest();
            const fastestPathNodes = findShortestPath(graph_fast, startNode, endNode);

            // Find SAFEST Path - Uses safety-weighted edges
            // This path maximizes safety score regardless of distance
            // Safety and distance are INDEPENDENT, so routes will differ
            const graph_safe = buildGraph_Safest(hour);
            const safestPathNodes = findShortestPath(graph_safe, startNode, endNode);

            // Draw both paths
            if (fastestPathNodes.length > 0) {
                fastestRouteLayer = drawRoute(fastestPathNodes, 'blue');
            }
            if (safestPathNodes.length > 0) {
                safestRouteLayer = drawRoute(safestPathNodes, 'green');
            }

            // Add markers for start and end
            if (nodes[startNode] && nodes[endNode]) {
                const startMarker = L.marker(nodes[startNode]).addTo(map)
                    .bindPopup(`Start: ${nodeNames[startNode]} (${startNode})`);
                const endMarker = L.marker(nodes[endNode]).addTo(map)
                    .bindPopup(`End: ${nodeNames[endNode]} (${endNode})`);
                routeMarkers.push(startMarker, endMarker);

                // Fit map to show both routes
                const bounds = L.latLngBounds([nodes[startNode], nodes[endNode]]);
                if (fastestRouteLayer) {
                    bounds.extend(fastestRouteLayer.getBounds());
                }
                if (safestRouteLayer) {
                    bounds.extend(safestRouteLayer.getBounds());
                }
                map.fitBounds(bounds, { padding: [50, 50] });
            }

            // Calculate metrics
            const fastestMetrics = calculatePathMetrics(fastestPathNodes, hour);
            const safestMetrics = calculatePathMetrics(safestPathNodes, hour);

            // Update details panel
            const detailsPanel = document.getElementById('details-panel');
            const isDayTime = (hour >= 6 && hour < 19);

            if (fastestMetrics && safestMetrics) {
                const fastestScoreColor = fastestMetrics.safetyScore >= 70 ? '#22c55e' : fastestMetrics.safetyScore >= 50 ? '#eab308' : '#ef4444';
                const safestScoreColor = safestMetrics.safetyScore >= 70 ? '#22c55e' : safestMetrics.safetyScore >= 50 ? '#eab308' : '#ef4444';

                detailsPanel.innerHTML = `
                    <div class="route-card safest">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-bold" style="color: #16a34a;">üõ°Ô∏è Safest Route</h3>
                            <span class="text-xs font-semibold px-3 py-1 rounded-full" style="background: rgba(34, 197, 94, 0.2); color: #16a34a;">RECOMMENDED</span>
                        </div>
                        <div class="safety-score" style="color: ${safestScoreColor};">
                            ${safestMetrics.safetyScore}
                            <span class="text-lg font-normal text-gray-500">/ 100</span>
                        </div>
                        <p class="text-sm font-semibold mb-4" style="color: #4b5563;">
                            üìè Distance: <span style="color: #1a1a1a;">${safestMetrics.distance} km</span>
                        </p>
                        <div class="flex flex-wrap gap-2">
                            <span class="metric-badge">üèóÔ∏è Infrastructure: ${safestMetrics.infra}</span>
                            <span class="metric-badge">üí° Lighting: ${safestMetrics.light}</span>
                            <span class="metric-badge">üö® Crime: ${safestMetrics.crime}</span>
                            <span class="metric-badge">üè™ Safe Havens: ${safestMetrics.amenity}</span>
                            <span class="metric-badge">‚ö†Ô∏è Disruptions: ${safestMetrics.disruption}</span>
                        </div>
                        ${safestMetrics.descriptions && safestMetrics.descriptions.length > 0 ? `
                        <div class="mt-4 pt-4 border-t" style="border-color: rgba(0, 0, 0, 0.1);">
                            <p class="text-xs font-semibold mb-2" style="color: #4b5563;">üìç Route Details:</p>
                            <ul class="text-xs space-y-1" style="color: #6b7280;">
                                ${safestMetrics.descriptions.map(desc => `<li>‚Ä¢ ${desc}</li>`).join('')}
                            </ul>
                        </div>
                        ` : ''}
                    </div>
                    <div class="route-card fastest">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-lg font-bold" style="color: #2563eb;">‚ö° Fastest Route</h3>
                        </div>
                        <div class="safety-score" style="color: ${fastestScoreColor};">
                            ${fastestMetrics.safetyScore}
                            <span class="text-lg font-normal text-gray-500">/ 100</span>
                    </div>
                        <p class="text-sm font-semibold mb-4" style="color: #4b5563;">
                            üìè Distance: <span style="color: #1a1a1a;">${fastestMetrics.distance} km</span>
                        </p>
                        <div class="flex flex-wrap gap-2">
                            <span class="metric-badge">üèóÔ∏è Infrastructure: ${fastestMetrics.infra}</span>
                            <span class="metric-badge">üí° Lighting: ${fastestMetrics.light}</span>
                            <span class="metric-badge">üö® Crime: ${fastestMetrics.crime}</span>
                            <span class="metric-badge">üè™ Safe Havens: ${fastestMetrics.amenity}</span>
                            <span class="metric-badge">‚ö†Ô∏è Disruptions: ${fastestMetrics.disruption}</span>
                        </div>
                        ${fastestMetrics.descriptions && fastestMetrics.descriptions.length > 0 ? `
                        <div class="mt-4 pt-4 border-t" style="border-color: rgba(0, 0, 0, 0.1);">
                            <p class="text-xs font-semibold mb-2" style="color: #4b5563;">üìç Route Details:</p>
                            <ul class="text-xs space-y-1" style="color: #6b7280;">
                                ${fastestMetrics.descriptions.map(desc => `<li>‚Ä¢ ${desc}</li>`).join('')}
                            </ul>
                        </div>
                        ` : ''}
                    </div>
                    <div class="mt-4 pt-4 border-t" style="border-color: rgba(0, 0, 0, 0.1);">
                        <p class="text-xs font-medium" style="color: #6b7280;">
                            ${isDayTime ? '‚òÄÔ∏è Daytime Mode: Lighting has minimal impact on safety' : 'üåô Nighttime Mode: Crime risk is weighted higher for your safety'}
                        </p>
                    </div>
                `;
            } else {
                detailsPanel.innerHTML = '<div class="empty-state"><p style="color: #ef4444;">No route found between selected locations</p></div>';
            }
        }

        // Search and filter nodes by name
        function searchNodes(query, excludeNodeId = null) {
            if (!query || query.trim() === '') {
                return [];
            }
            
            const results = [];
            const lowerQuery = query.toLowerCase();
            
            for (const nodeId in nodeNames) {
                if (excludeNodeId && nodeId === excludeNodeId) continue;
                
                const name = nodeNames[nodeId];
                const searchText = `${name} (${nodeId})`;
                
                if (name.toLowerCase().includes(lowerQuery) || 
                    nodeId.toLowerCase().includes(lowerQuery) ||
                    searchText.toLowerCase().includes(lowerQuery)) {
                    results.push({ nodeId, name, displayText: searchText });
                }
            }
            
            return results;
        }

        // Show search results dropdown
        function showSearchResults(inputId, results) {
            const resultsDiv = document.getElementById(`${inputId}-results`);
            resultsDiv.innerHTML = '';
            
            if (results.length === 0) {
                resultsDiv.classList.add('hidden');
                return;
            }
            
            resultsDiv.classList.remove('hidden');
            
            results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'search-result-item';
                item.innerHTML = `
                    <div class="font-semibold text-gray-900">${result.name}</div>
                    <div class="text-xs text-gray-500 mt-1">${result.nodeId}</div>
                `;
                item.addEventListener('click', () => {
                    const input = document.getElementById(inputId);
                    input.value = result.name;
                    input.dataset.nodeId = result.nodeId;
                    resultsDiv.classList.add('hidden');
                    
                    // Check if panel should expand
                    checkPanelExpansion();
                    
                    updateAllRoutes();
                });
                resultsDiv.appendChild(item);
            });
        }
        
        // Check if panel should be expanded
        function checkPanelExpansion() {
            const startInput = document.getElementById('start-node');
            const endInput = document.getElementById('end-node');
            const panel = document.getElementById('control-panel');
            
            const hasStart = startInput.dataset.nodeId && startInput.dataset.nodeId !== '';
            const hasEnd = endInput.dataset.nodeId && endInput.dataset.nodeId !== '';
            
            if (hasStart && hasEnd) {
                // Both locations selected - expand panel
                panel.classList.remove('minimized');
                
                // Animate panel to side after a short delay
                setTimeout(() => {
                    if (!panelAnimated) {
                        panel.classList.add('slide-to-side');
                        panelAnimated = true;
                    }
                }, 300);
            } else {
                // Not both selected - keep minimized
                panel.classList.add('minimized');
                panel.classList.remove('slide-to-side');
                panelAnimated = false;
            }
        }
        
        // Animate panel to side
        function animatePanelToSide() {
            checkPanelExpansion();
        }

        // Setup search input handlers
        function setupSearchInputs() {
            const startInput = document.getElementById('start-node');
            const endInput = document.getElementById('end-node');
            
            // Start location search
            startInput.addEventListener('input', function() {
                const query = this.value;
                const endNodeId = endInput.dataset.nodeId;
                
                // If input is cleared, clear the node ID
                if (!query || query.trim() === '') {
                    startInput.dataset.nodeId = '';
                    checkPanelExpansion();
                }
                
                const results = searchNodes(query, endNodeId);
                showSearchResults('start-node', results);
            });
            
            startInput.addEventListener('blur', function() {
                // Hide results after a short delay to allow click events
                setTimeout(() => {
                    document.getElementById('start-node-results').classList.add('hidden');
                }, 200);
            });
            
            // End location search
            endInput.addEventListener('input', function() {
                const query = this.value;
                const startNodeId = startInput.dataset.nodeId;
                
                // If input is cleared, clear the node ID
                if (!query || query.trim() === '') {
                    endInput.dataset.nodeId = '';
                    checkPanelExpansion();
                }
                
                const results = searchNodes(query, startNodeId);
                showSearchResults('end-node', results);
            });
            
            endInput.addEventListener('blur', function() {
                // Hide results after a short delay to allow click events
                setTimeout(() => {
                    document.getElementById('end-node-results').classList.add('hidden');
                }, 200);
            });
        }

        // Populate Node Dropdowns
        function populateNodeDropdowns() {
            // Set default values for search inputs (empty initially)
            const startInput = document.getElementById('start-node');
            const endInput = document.getElementById('end-node');
            
            // Don't set default values - let user search
            startInput.value = '';
            startInput.dataset.nodeId = '';
            
            endInput.value = '';
            endInput.dataset.nodeId = '';
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize Leaflet map with a modern tile layer
            map = L.map('map').setView([49.28, -123.12], 14);
            
            // Use CartoDB Positron for a cleaner, modern look
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            // Populate node dropdowns
            populateNodeDropdowns();
            
            // Setup search functionality
            setupSearchInputs();

            // Initialize time slider
            const slider = document.getElementById('time-slider');
            const timeLabel = document.getElementById('time-label');
            const currentHour = new Date().getHours();

            // Set slider to current hour
            slider.value = currentHour;
            timeLabel.textContent = formatTime(currentHour);

            // Add event listeners
            slider.addEventListener('input', function() {
                const hour = parseInt(this.value);
                timeLabel.textContent = formatTime(hour);
                updateAllRoutes();
            });

            // Load CSV data and calculate scores
            try {
                await loadCSVData();
                console.log('CSV data loaded and scores calculated');
            } catch (error) {
                console.error('Error loading CSV data:', error);
                // Continue with default scores if loading fails
            }

            // Search inputs already trigger updateAllRoutes via setupSearchInputs
            // Don't draw initial route - wait for user to select locations
        });
    </script>
</body>
</html>
